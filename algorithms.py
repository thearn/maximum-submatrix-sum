from scipy.signal import fftconvolve as conv
import numpy as np
import itertools
import time


from typing import Tuple, Any

def local_search(A: np.ndarray, loc: Tuple[slice, slice]) -> Tuple[Tuple[slice, slice], float]:
    """
    Utility function to verify local optimality of a
    subarray slice specification 'loc' of array 'A'

    Checks the sum of all subarrays generated by perturbing each
    index by 1 in value

    Needed due to indeterminacy of precise indices corresponding
    to maximization of the convolution operation
    """
    r1, r2, c1, c2 = loc[0].start, loc[0].stop, loc[1].start, loc[1].stop
    mx = A[loc].sum()
    for i, j, k, l in itertools.product([-1, 0, 1], repeat=4):
        loc_ = (slice(r1 + i, r2 + j), slice(c1 + k, c2 + l))
        val = A[loc_].sum()
        if val >= mx:
            mx = val
            loc2 = loc_
    return loc2, mx


def brute_submatrix_max(A: np.ndarray) -> Tuple[Tuple[slice, slice], float, float]:
    """
    Searches for the rectangular subarray of A with maximum sum
    Uses brute force searching
    """
    M, N = A.shape
    t0 = time.time()
    this_location, max_value = ((0, 0), (0, 0)), 0
    for m, n in itertools.product(range(M), range(N)):
        for i, k in itertools.product(range(M - m + 1), range(N - n + 1)):
            this_location = (slice(i, i + m), slice(k, k + n))
            value = A[this_location].sum()
            if value >= max_value:
                max_value = value
                location = this_location
    t = time.time() - t0
    return location, max_value, t


def fft_submatrix_max(A: np.ndarray) -> Tuple[Tuple[slice, slice], float, float]:
    """
    Searches for the rectangular subarray of A with maximum sum
    Uses FFT-based convolution operations
    """
    M, N = A.shape
    this_location, max_value = ((0, 0), (0, 0)), 0
    t0 = time.time()
    for m, n in itertools.product(range(2, M), range(2, N)):
        convolved = conv(A, np.ones((m, n)), mode='same')
        row, col = np.unravel_index(convolved.argmax(), convolved.shape)
        # index offsets for odd dimension length:
        if m % 2 == 1:
            m_off = 1
        else:
            m_off = 0
        if n % 2 == 1:
            n_off = 1
        else:
            n_off = 0

        this_location = (
            slice(row - m // 2, row + m // 2 + m_off), slice(col - n // 2, col + n // 2 + n_off))
        value = A[this_location].sum()

        if value >= max_value:
            max_value = value
            location = this_location
    location, max_value = local_search(A, location)
    t = time.time() - t0
    return location, max_value, t
